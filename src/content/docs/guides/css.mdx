---
title: "Introduction to CSS"
description: "How to style your website."
template: splash
---

import { Card } from "@astrojs/starlight/components";
import { Aside } from "@astrojs/starlight/components";
import { Steps } from '@astrojs/starlight/components';
import { Tabs, TabItem } from "@astrojs/starlight/components";
import { FileTree } from '@astrojs/starlight/components';
import { Sandpack } from "@codesandbox/sandpack-react";


## What does this cover?

1. Get started with styling
2. CSS selectors
3. CSS structures
4. The box Model
5. Other CSS basics

## What is CSS?

Cascading Style Sheets (CSS) is a language used to describe the design and layout of HTML documents. It dictates how elements should be presented - whether that's on-screen, in print, in speech, or in other media types.

Like HTML, CSS is a **Declarative Language** used for Front end Development. Remember that CSS runs in the browser so different (and older) browsers may display your CSS differently or not at all!

The development of CSS is overseen by the [World Wide Web Consortium (W3C)](https://www.w3.org/Style/CSS/#specs).


:::note[Useful Links]{icon="heart"}
- [CSS Zen Garden - The Classic!](https://csszengarden.com/)
- [Adam Argyle](https://nerdy.dev/4-css-features-every-front-end-developer-should-know-in-2026)
- [Jen Simmons](https://labs.jensimmons.com/)
- [Sarah Soueidan](https://www.sarasoueidan.com/blog/)
- [Andy Clarke](https://stuffandnonsense.co.uk/about)
- [Tailwind CSS - going all in on utility classes](https://tailwindcss.com/)
- [CSS Tricks - long-running blog about CSS](https://css-tricks.com/category/articles/)
:::

## The CSS file
Whilst you can style elements using a `<style>` tag in the `head` of your HTML, if you have a lot of styles to add, it's much better practice to make a separate CSS file.

<Aside type="tip">
You can add a sub-folder for your CSS (such as 'assets' or 'styles') if you like things tidy! Just remember to put the right file path in your `<link>`.
</Aside>

```html
<link rel="stylesheet" href="style.css">
```

## CSS Syntax
CSS is comprised of three main parts:

- **Selectors**
- **Properties**
- **Values**

These look slightly different depending on whether you're using inline CSS or internal/external CSS.

### Inline CSS

```html
<p style="color:green; font-style:italic;">This is a paragraph.</p>
```

### Internal/External CSS
```html
<style>
  p {color: green; font-style: italic;}
</style>
```

```css
body {
 font-family: Open Sans, Arial; 
 color: #000000;
 font-size: 9px;
 background: #ffffff;
 line-height: 16px;
}
```

CSS is a rules-based language; we define the style rules by picking out groups of elements and declaring style properties for them.

We start with a **Selector** - this tells our browser which elements these style rules apply to.

We then add in declarations, which are made up of **Properties** and **Values** - what style aspect we want to change, and what we want to change it to.

Only properties inside the curly braces will be changed!

### Colo(u)r in CSS

```css
body {
  color: CornflowerBlue;
  color: #af0f9d;
  color: rgba(255, 99, 71, 0.9);
  color: hsl(85, 88%, 51%);
}
```
There's a few ways we can define colour in CSS - which you choose to
use might depend on the kind of colour you need.

The simplest way is by just typing in a colour name. CSS has ~140
[inbuilt named colours](https://developer.mozilla.org/en-US/docs/Web/CSS/Reference/Values/named-color) to choose from.

You can also use a colour hex code. For example,
`#000000` is black, whilst `#ffffff` is white.

If you need to control opacity, try using
`rgba(255,255,255,1)`. This allows you to set red, green,
blue and alpha values.

You could also opt for `hsl(180,61%,100%)` which will
adjust hue, saturation, and lightness.

## CSS Referencing
There are a huge number of different CSS properties - more than we could
ever cover.

An important part of any developer toolkit is a reference guide for the
language you're working with. Learning how to use a reference guide is
the most valuable thing you can do!

:::note[MDN CSS Reference]
  The [MDN CSS reference](https://developer.mozilla.org/en-US/docs/Web/CSS) is probably the most authroatative guide to all CSS features.
:::

## CSS Selectors: the Big Three
As we've seen, CSS rules always start with a Selector - or a list of
selectors. There are quite a few types of selector, but the you'll use
the most are:

<Card title="Type selector">
- Selects elements solely by the element tag name, e.g. `h1`, `img`, `a`, etc.
- All elements of this type in HTML will be selected for styling.
- The simplest selector type.

```css
h1 {
  font-family: "Montserrat", Arial, sans-serif; 
  text-align: left;
  text-transform: uppercase; 
  mix-blend-mode: overlay; 
  letter-spacing: 2px;
}
```
```html
<h1>welcome to my website!</h1>
```
</Card>

<Card title="Class selector">
- Selects elements by Class - an attribute you can give multiple elements in HTML.
- All elements with the same Class name will be selected.
- Can be used to select multiple similar elements without having to select all of them.

```css
.quote { 
  text-align: center;
  font-size: 13px;
  font-style: italic; 
}
```
```html
<h1 class="quote">welcome to my website!</h1>
```

The example before used only one class name for the element. But if
every HTML element could only belong to a single class, that would
create a lot of work for us!

Luckily, HTML allows us to stack class attributes and apply multiple
style rules at once:

```css
.green { color: green; }
.bold { font-weight: bold; }
.main-heading { font-size: 4rem;}
```
```html
<h1 class="green bold main-heading">Hello World!</h1>;
```     
</Card>

<Card title="ID selector">
- Selects a HTML element for styling by referencing the ID attribute.
- Only one HTML element will be selected, since IDs should be unique.
- Used to make style changes to one element without changing the others.

```css
#galaxy-backdrop {
  width: 100vw;
  height: 100vh;
  position: fixed;
  top: 0;
  left: 0;
  background: url("galaxy.jpg"); 
  background-size: cover; 
  color: #000000;
}
```
```html
<section id="galaxy-backdrop">
  <h1>Welcome to my site!</h1>;
</section>
```
</Card>

<div className="not-content">
<Sandpack
  client:load
  files={{
    "/index.html":
`<!DOCTYPE html> 
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>CSS</title>
    <link rel="stylesheet" href="style.css">
  </head>

  <body>
    <h1>Make this heading Magenta and give it a Magenta glow using the text-shadow property.</h1>
    <p>Change all typography in the body to the 'Courier New' font.</p>
    <p>Give the body a dark background colour...</p>
    <p>Make all paragraphs Aquamarine!</p>
    <p>Make <a href="https://www.w3.org/">this link</a> a suitable colour using a hex code value.</p>
  </body>
</html>`,
  "/style.css": 
  `body {
  
  }

  h1 {
  
  }

  p {
  
  }

  a {
  
  }`,
    "/solution.css": 
  `body {
    font-family: "Courier New", Courier, monospace;
    background: darkslateblue;
  }

  h1 {
    color: magenta;
    text-shadow: 0 0 12px magenta;
  }

  p {
    color: aquamarine;
  }

  a {
    color: #00ffff;
  }
`
  }}
        template="static"
        theme="dark"
        options={{ showLineNumbers: true, activeFile: "/style.css", }}
      />
</div>

## Compound selectors/Selector lists

Once you have a grasp on the three main selector types, you can start
blending them together (Compound selectors) and selecting compounding
type and class selectors, within a selector list:

This solely targets paragraph and span elements which have the special class.

```css
p.special, span.special {
  color: orange;
  font-weight: bold; 
}
```

```html
<p class="special">this text looks very <span class="special">special!</span></p>
<h1 class="special">this text doesn't look special at all, because h1 isn't on the selector list for the .special class</h1>
```

## Combinators: styling by location

- There are times you may want to target something based on where it is
within your HTML structure.
- Using combinators, we can combine multiple selectors to explicitly
target an element based on where it is in relation to another element.
- Selectors using combinators are called Complex Selectors.
- There are many different types of combinator, and you can use multiple
combinators at once!

```css
// Decendant combinator
article p { color: rebeccapurple; }

// Next-sibling combinator
h1+p { font-size: 200%; }

// Child combinator
section > article { font: Montserrat; }

// Subsequent-sibling combinator
p~img { width: relative; }
```

## Pseudo-classes: styling by state
We can also target elements based on their current state, or on a number
of other external factors (e.g. browser history, time, etc.).

A great example of this is styling links. The anchor `<a>` element has different states:

- Unvisited
- Visited
- Hovered over
- Focused by the keyboard
- Active (e.g by being clicked)

We call these selectors pseudo-classes.

<div className="not-content">
<Sandpack
  client:load
  files={{
    "/index.html":
`<!DOCTYPE html> 
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>CSS</title>
    <style>
      body { padding: 1rem; background: darkslateblue; }
      a { color: white; font-size: 2rem; text-decoration: none; } 
      a:visited { color: yellow; }
      a:hover { text-decoration: underline; }
      a:active { color: cornflowerblue; }
    </style>
  </head>

  <body>
    <p>
      <a href="#">I'm a link!</a>
    </p>
  </body>
</html>`
  }}
        template="static"
        theme="dark"
        options={{ showLineNumbers: true }}
      />
</div>


## Selectors
| Selector | Description | Example |
|----------|-------------|---------|
| Type Selector | Targets all relevant HTML elements. | `h1 {}` |
| Class Selector | Targets elements based on the Class attribute. | `.card {}` |
| ID Selector | Targets element with specific ID value. | `#hero {}` |
| Attribute Selector | Makes selection based on if an element has a specific attribute/an attribute value. | `a[title] {}`<br/>`a[href='www.wikipedia.com'] {}` |
| Pseudo-classes | Selects elements that are in a specific state. | `a:hover {}` |
| Pseudo-elements | Selects a very specific part of an element. | `p::first-line {}` |
| Universal Selector | Selects all elements. | `* {}` |
| Combinators | Combines other selectors to target elements. | `#myId > .myClass + p::first-line {}` |

## Combinators
| Combinator | Description | Example |
|------------|-------------|---------|
| Next-sibling combinator | Separates two selectors and targets instances where the second element immediately follows the first. | `h1+p {}` |
| Subsequent sibling combinator | Separates two selectors and targets all instances of the second element following the first, provided they are at the same hierarchy level. | `h2~span {}` |
| Descendant combinator | Separates two selectors. Targets all instances of the second element when nested inside the first. | `section img{}` |
| Child combinator | Separates two selectors and targets instances where the second element is a direct child of the first. | `div > span {}` |

## Specificity
But what happens when two selectors select the same HTML element?

```css
.special { color: red; }
p { color: blue; }
```

**Can anyone guess what colour the text will end up being?**

### Inline > ID > Class > Type
- Luckily, CSS has in-built rules that decide which selector comes out
on top in the event of a conflict.
- Class selectors will always beat out element type selectors; ID
selectors will always beat out both.
- Inline styling using the style= attribute in HTML will beat all of
them.
- This is what we call the Specificity rule.

So in our example, according to specificity, the text will be red, as
the rules for the class selector beat the element selector.

But what if we have two selectors of the same specificity in conflict?

```css
p { color: red; }
p { color: blue; }
```

Here, we have two rules for `<p>`. So which colour will our text be this time?

<details>
  <summary><strong>Reveal Answer</strong></summary>
  Anyone who guessed blue: congratulations! The text would be blue because the declaration for blue comes later in the stylesheet.
  This rule is called the Cascade rule - basically, the latest rule in conflict overwrites the others.
</details>

### Selector Specificity
| Weight Category | Selectors | Weighting |
|-----------------|-----------|-----------|
| ID | ID Selectors (`#id`) | 100 |
| Class | Class Selectors (`.class`)<br/>Attribute Selectors (`[attribute="..."]`)<br/>Pseudo-classes (`:pseudo-class`) | 10 |
| Type | Element Type Selectors (`p, h1, img`)<br/>Pseudo-elements (`::pseudo-element`) | 1 |
| No value | Universal Selector `*`<br/>Combinators `+, >, ~, \|, \|\|, â£` | 0 |

Almost all selectors have their own level of specificity you can use to calculate which will win out in a clash.

It's worth noting that an infinite number of selectors in one weight category cannot surpass even a single selector of a higher weight category. 100 class selectors will always be lower priority than 1 ID selector.

| Selector | IDs | Classes | Elements | Total |
|----------|-----|---------|----------|-------|
| `h1` | 0 | 0 | 1 | 001 |
| `h1+p::first-letter` | 0 | 0 | 2 | 002 |
| `li>button[aria-expanded="true"] .button-icon` | 0 | 2 | 2 | 022 |
| `#identifier` | 1 | 0 | 0 | 100 |
| `button:not(#mainBtn, .cta)` | 1 | 0 | 1 | 101 |

All this can get quite confusing when you start using complex selectors. The above table shows a way to track specificity that might be helpful.

A CSS reference guide will provide details on a selector's specificity, and any unique quirks it might have - the :not() pseudo-class used here is a very odd character!

Remember: the Universal selector (*), combinators, and a few pseudo-classes have no effect on specificity.

## Inheritance

```css
p { color: green; }
```
```html
<p>this paragraph has <em>emphasised text</em></p>
```

Also significant here is the concept of inheritance - some CCS
properties cause child elements to inherit the properties of the
parent element by default.

You don't need to be an expert on this yet, but it can cause
unexpected behaviour in your styling. So if things aren't looking
quite right, it might be an inheritance issue.

## Understanding the Cascade

<Steps>
1. **Relevance:** User agent finds all rule blocks with a selector match for each element.
2. **Importance:** Sorts rules based on whether they are Normal, or Important. Important styles are those with the `!important` flag.
3. **Style Origin:** Within each of the two importance options, sorts CSS rules by whose stylesheet they're in: the user-agent, the author (developer), or the website user. Priority differs based on these answers, combined with the importance rule.
4. **Cascade Layers:** Within these six categories, sorts rules again by Cascade Layer. Cascade layers can be used by developers to add extra levels of priority to stylesheets.
5. **Specificity:** Sorts rules by specificity of selectors, as we have explored.
6. **Scoping Proximity:** This helps resolve conflicts between declarations within a @scope. @scope sets very specific conditions for when a CSS rule should be applied.
7. **Source Order:** When two selectors in the same origin & cascade layers have the same importance, specificity, and scope proximity, the last declared selector wins.
</Steps>

We've talked about selector specificity and the order selectors are
declared in, but these are only two steps in a much larger process web
browsers go through to decide which CSS rules are applied.

User agents follow the steps above from 1-7: only rules 'still in
the running' each time move to the next step. Once there is only one
left, no more rules are checked.

You don't have to understand all these concepts right now - just know
they exist, so that you can spot them in other people's CSS.

### Style Origin
<Steps>
1. normal user-agent styles (default browser styles)
2. normal user styles
3. normal author styles
4. styles being animated
5. `!important` author styles
6. `!important` user styles
7. `!important` user-agent styles
8. styles being transitioned
</Steps>

As we've seen, the origin of style rules can greatly impact their level of specificity in the cascade order.

The user-agent has the lowest priority with regard to normal styles, but one of the highest when styles are `!important`.

Users of your site may also be applying their own styles to your page (think Chrome Extensions, for instance.) Their styles are of medium importance for both normal and `!important` buckets.

It's useful to know this so you know how your styles (author styles) fit into this origin order.

## What is the Box Model?
Everything in CSS has a **box** around it.

These boxes have several properties which will affect how they are laid
out on our webpage, and how they interact with other elements.

Boxes have an Outer display type and an Inner display type:

- Outer display controls how the element sits on the page alongside other elements
- Inner display controls the layout of everything within the box - including any nested elements.

We can set these display types using the display property.

### Outer Display Type
Outer display type controls the flow layout of elements on the page.

<Card title="When this is set to block">
- The box will break onto a new line.
- Width & height properties are respected. If no width is given, the box will extend to fill its containing element.
- Padding, margins & borders will cause other elements to be pushed away from the box.
- Some elements, like `<h1>` and `<p>`, use block as their outer display type by default.
</Card>

<Card title="When this is set to inline">

- Width & height properties will not apply.
- Top & bottom padding, margins, & borders will not push other inline elements away.
- Left & right padding/margins/borders will still push other inline elements away.
- HTML elements, such as `<a>`, `<span>`, `<em>` and `<strong>` use inline as their default outer display type.
</Card>

<Card title="When this is set to inline-block">
- The box will not break onto a new line, but it will respect width & height.
- This also avoids the overlapping you often see in a purely inline layout.
- HTML elements such as `<img>`, `<button>`, `<textarea,>`, `<input>`, and `<select>` use `inline-block` as their default outer display type.
</Card>

### The Standard Box Model

CSS boxes are made up of four main parts:

- Content
- Padding
- Border
- Margin

In the standard CSS box model, when you set the width and height properties on a box, these values apply only to the content section of your CSS box.

properties on a box, these values apply only to the content section of your CSS box.

Any padding & borders are then added on top of these dimensions to get
the total size taken up by the box. Margins do not count!

The box model only applies fully to block boxes. Inline boxes do adopt some features, but not all of them!


<div className="not-content">
<Sandpack
  client:load
  files={{
    "/index.html":
`<!DOCTYPE html> 
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>CSS</title>
    <style>
      .box {
        width: 150px;
        height: 50px;
        margin: 10px;
        padding: 25px;
        border: 5px solid black;
      }
    </style>
  </head>

  <body>
    <div class="box"></div>
  </body>
</html>`
  }}
        template="static"
        theme="dark"
        options={{ showLineNumbers: true }}
      />
</div>

Looking at this CSS, what would the size of our CSS box actually be?

### Margins

```css
.box { margin: 10px -5px 10px 20px; } 

.axis-based {
  margin: 20px 30px;
}

.longhand {
  margin-top: 10px; 
  margin-right: -5px;
  margin-bottom: 10px; 
  margin-left: 20px; 
}
```
- Margins are the invisible space around your box, which pushes other elements away from it.
- They can have positive and negative values; setting a negative value causes your box to overlap with other elements on the page.
- Remember - margins don't count towards box size!
- Control all margins of an element at once using the margin property, or control each side using longhand.
 

### Margin Collapsing

<div className="not-content">
<Sandpack
  client:load
  files={{
    "/index.html":
`<!DOCTYPE html> 
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>CSS</title>
    <style>
      section {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 100%;
        height: 50px; 
        background: violet;
        margin: 10px 0;
      }
      section:nth-of-type(2) {
        margin: 30px 0 5px;
      }
      section:nth-of-type(3) {
        margin: 20px 0 50px;
      }
      section:nth-of-type(4) {
        margin: -10px 0 10px;
      }
    </style>
  </head>

  <body>
    <main>
      <section>
         margin: 10px 0;
      </section>
      <section>
        margin: 30px 0 5px;
      </section> 
      <section>
          margin: 20px 0 50px;
      </section>
      <section>
          margin: -10px 0 10px;
      </section>    
    </main
  </body>

</html>`
  }}
        template="static"
        theme="dark"
        options={{ showLineNumbers: true }}
      />
</div>

- Depending on whether two elements whose margins touch have positive or negative margins, you will get different results.
- This is the result of something called Margin Collapse.
- Two positive margins will collapse to become one margin - the biggest value margin.
- Two negative margins will collapse, with the smallest value being used.
- If only one margin is negative, it will be subtracted from the other.
- There's a lot of rules surrounding margin collapse - your reference guide can help if your boxes aren't looking the way you expect.

### Borders

```css
.box {
  border: 5px solid blue;
}
.longhand {
  border-top-width: 2px;
  border-bottom-style: dotted;
  border-left-color: orange;
}
```
- Borders are drawn between the margin and the padding of a box.
- There are a large number of properties available for styling borders, as each side has its own width, style, and colour properties.
- You can use the border property to change all these values at once, or use longhand to apply more specific styling.

### Padding

```css
.box { 
  padding: 7px 7px 10px 10px;
} 

.longhand {
  padding-top: 7px; 
  padding-bottom: 7px; 
  padding-left: 10px; 
  padding-right: 10px;
}
```

- Padding sits between the border and the content area and is used to push the content away from the border.
- There is no negative value for padding; the lowest possible value is 0.
- Any background applied to your element will display behind the padding.
- Like margins and borders, there's long and shorthand for padding.

### The (Widely-Preferred) Alternate Box Model

- When using the alternative box model, width & height properties affect the whole visible box on the page.
- Any border and padding values you then set are subtracted from the total width & height, leaving the size value of your content.
- This can be useful if you have very specific dimensions your box cannot exceed.
- You can switch to the alternate box model in CSS by using the property `box-sizing: border-box;`

:::tip
- Developers often use the alternate box model for all their elements.
- To do that, we set the `box-sizing` property on the `<html>` element.
- We then use the universal selector to ensure all our elements inherit that value from the HTML element.
- This often forms part of a 'CSS Reset' - boilerplate code used to set defaults prior to any project-related styles.
```css
html {
  box-sizing: border-box;
}
*, *::before, *::after {
  box-sizing: inherit;
}
```
:::

## Sizing Content

```css
.box {
  display: block;
  border: 5px solid red;
  padding: 2em;
  width: 50%;
}
```

- We've mostly been sizing content so far using the pixel measurement (px).
- Using absolute values can often end with content overflowing from their boxes.
- We can instead use relative values to set the size of an element. The element will then be sized to a percentage of its parent element.
- When no percentage is set, a block element will take up 100% of available width. So a percentage value may make it more responsive to different screens.

## Styling Images
 
**`object-fit: contain;`**

- shrinks to fit box on longest side
- maintains aspect ratio
- results in 'letterboxing'

**`object-fit: cover;`**

- crops to fit box on shortest side
- maintains aspect ratio
- does not contain whole image

**`object-fit: fill;`**

- resizes to fit box on both sides
- does not maintain aspect ratio

<div className="not-content">
<Sandpack
  client:load
  files={{
    "/index.html":
`<!DOCTYPE html> 
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>CSS</title>
    <style>

    figure {
      margin: 1rem 0;
    }

    figcaption {
      display: block;
      font-family: sans-serif;
      margin: 0.5rem 0 0 0;
    }

    img {
      background: black;
      display: block;
    }

    img.fixed {
      width: 128px;
      height: 128px;
    }

    .contain {
      object-fit: contain;
    }

    .cover {
      object-fit: cover;
    }

    .fill {
      object-fit: fill;
    }
     
    </style>
  </head>

  <body>
    <main>

      <figure>
        <img src="https://picsum.photos/id/237/300/200">
        <figcaption>Original</figcaption>
      </figure>

      <figure>
        <img class="fixed contain" src="https://picsum.photos/id/237/300/200">
        <figcaption>Contain</figcaption>
      </figure>

      <figure>
        <img class="fixed cover" src="https://picsum.photos/id/237/300/200">
        <figcaption>Cover</figcaption>
      </figure>

      <figure>
        <img class="fixed fill" src="https://picsum.photos/id/237/300/200">
        <figcaption>Fill</figcaption>
      </figure>
    </main
  </body>

</html>`
  }}
        template="static"
        theme="dark"
        options={{ showLineNumbers: true }}
      />
</div>

Whilst CSS can't affect the internal layout of an image or video, we
can adjust how they are laid out on the page.

If we try to place an image inside a CSS box that isn't the same size
as the image:

- The image will not stretch to fit a larger box
- The image will overflow out of a smaller box.
  
We can use the `object-fit` property to ensure our image completely covers our box.

## @-rules: Importing Fonts

```css
@font-face {
  font-family: 'MyWebFont';
  src: url('myfont.woff2') format('woff2');
  font-display: swap;
}
```

- At-rules in CSS are specific instructions we can give on how we want CSS to behave. We declare an at-rule by using @.
- The rule then lasts until the next ; on its hierarchy level, or the next CSS block - whichever comes first.
- We can use the `@font-face` rule to import custom fonts for our text: either from our own locally-installed fonts, or from external sources.
- Adding both a local and url source allows for a backup option should the user not have that font installed!


## @-rules: Cascade Layers

```css
/* Layer order */
@layer reset, base, layout;

/* Layer styles */
@layer reset {
/* apply a natural box layout model to all elements, but allowing components to change */
  html {
    box-sizing: border-box;
  }
  *, *:before, *:after {
    box-sizing: inherit;
  }
}

@layer base {
  body {
    display: flex;
    font-family: "Courier New", Courier, monospace;
  }
  a {
     color: rebeccapurple;
  }
}

@layer layout {
  #site-header nav {
    display: flex;
    align-items: center;
    justify-content: space-between;
  }
}

/* Styles with no layer take priority */
a {
  color: cornflowerblue;
}
```
      
- Another great use of @-rules is for the creation of Cascade Layers.
- We talked a little bit before about CSS layers in relation to the cascade - they allow us to create added layers of specificity into our stylesheet.
- There's a few ways to go about adding layers - our example is the `@layer` block at-rule, which creates a block for that layer which you can add styles into.
- The order of layer creation is important, as it affects the level of hierarchy amongst layers. Your reference guide should be able to explain more about this.
