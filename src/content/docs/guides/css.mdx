---
title: "Introduction to CSS"
description: "How to style your website."
template: splash
---

import { Card } from "@astrojs/starlight/components";
import { Aside } from "@astrojs/starlight/components";
import { Tabs, TabItem } from "@astrojs/starlight/components";
import { FileTree } from '@astrojs/starlight/components';
import { Sandpack } from "@codesandbox/sandpack-react";


## Objectives

1. Get started with styling
2. Get started with styling
3. CSS selectors
4. CSS structures
5. The box Model
6. Other CSS basics

## What is CSS?

Cascading Style Sheets (CSS) is a language used to describe the design
and layout of HTML documents. It dictates how elements should be
presented - whether that's on-screen, in print, in speech, or in other
media types.

Like HTML, CSS is a Declarative Language used for Frontend Development.

Also like HTML, CSS no longer has a unified release version. After CSS
2.1, it was decided that CSS would be updated as multiple separate
modules, rather than all at once. The core CSS syntax is currently on
Level 3, whilst the color module is on level 5! We call this a living
sandard language.

The development of CSS is overseen by the World Wide Web Consortium (W3C).

## The CSS file
Whilst you can style elements within the `head` of
your HTML, it's much better practice to make a separate CSS file in VS
Code.

Jump into VS Code and create a new file in your Intro to Web project folder called `style.css`.

We can then head to the `index.html` file, and add a `<link>` to our stylesheet.

<Aside type="tip">
You can add in a sub-folder for your CSS if you like things tidy! Just remember to put the right file path in your `<link>`.
</Aside>

```html
<link rel="stylesheet" href="style.css">
```

## CSS Syntax
CSS is comprised of three main parts: Selectors, Properties, and Values.

These look slightly different depending on whether you're using inline
CSS or internal/external CSS.

## Inline CSS

```html
<p style="color:green; font-style:italic;">This is a paragraph.</p>
```

## Internal/External CSS
```css
p {color: green; font-style: italic;}
```

## CSS Syntax

```css
body {
 font-family: Open Sans, Arial; 
 color: #000000;
 font-size: 9px;
 background: #ffffff;
 line-height: 16px;
}
```

CSS is a rules-based language; we define the styling rules by picking
out groups of elements and declaring style properties for them.

We start with a Selector - this tells our browser which elements these
style rules apply to.

We then add in declarations, which are made up of Properties and
Values - what style aspect we want to change, and what we want to
change it to.

Only properties inside the curly braces will be changed!

## Colo(u)r in CSS

```css
body {
  color: CornflowerBlue;
  color: #af0f9d;
  color: rgba(255, 99, 71, 0.9);
  color: hsl(85, 88%, 51%);
}
```
There's a few ways we can define colour in CSS - which you choose to
use might depend on the kind of colour you need.

The simplest way is by just typing in a colour name. CSS has ~140
inbuilt colours to choose from.

You can also use a colour hex code. For example,
<code>#000000</code> is black, whilst <code>#ffffff</code> is white.

If you need to control opacity, try using
<code>rgba(255,255,255,1)</code>. This allows you to set red, green,
blue and alpha values.

You could also opt for <code>hsl(180,61%,100%)</code> which will
adjust hue, saturation, and lightness.

## CSS Referencing
There are a huge number of different CSS properties - more than we could
ever cover.

An important part of any developer toolkit is a reference guide for the
language you're working with. Learning how to use a reference guide is
the most valuable thing you can do!

It may be tempting to try and ask AI for the answer - avoid this if you
can, especially for living standard languages that are updated
regularly. AI training data is often years out of date, and won't always
provide a reliable answer.

Trust your own brain! You are smart!

## CSS Selectors: the Big Three
As we've seen, CSS rules always start with a Selector - or a list of
selectors. There are quite a few types of selector, but the you'll use
the most are:

<Card title="Type selector">
- Selects elements solely by the element tag name, e.g. `h1`, `img`, `a`, etc.
- All elements of this type in HTML will be selected for styling.
- The simplest selector type.

```css
h1 {
  font: bold 12px/20px Montserrat; 
  text-align: left;
  text-transform: uppercase; 
  mix-blend-mode: overlay; 
  letter-spacing: 2px;
}
```
```html
<h1>welcome to my website!</h1>
```
</Card>

<Card title="Class selector">
- Selects elements by Class - an attribute you can give multiple elements in HTML.
- All elements with the same Class name will be selected.
- Can be used to select multiple similar elements without having to select all of them.

```css
.quote { 
  text-align: center;
  font-size: 13px;
  font-style: italic; 
}
```
```html
<h1 class="quote">welcome to my website!</h1>
```

The example before used only one class name for the element. But if
every HTML element could only belong to a single class, that would
create a lot of work for us!

Luckily, HTML allows us to stack class attributes and apply multiple
style rules at once:

```css
.green { color: green; }
.bold { font-weight: bold; }
```
```html
<h1 class="green bold">Hello World!</h1>;
```     
</Card>

<Card title="ID selector">
- Selects a HTML element for styling by referencing the ID attribute.
- Only one HTML element will be selected, since IDs should be unique.
- Used to make style changes to one element without changing the others.

```css
#sidebar {
  width: 400px;
  height: 100%;
  position: fixed;
  top: 0;
  left: 0;
  display: table;
  background: url("galaxy.jpg"); 
  background-size: cover; 
  color: #000000;
}
```
```html
<section id="sidebar">
  <h1>Welcome to my site!</h1>;
</section>
```
</Card>

<div className="not-content">
<Sandpack
  client:load
  files={{
    "/index.html":
`<!DOCTYPE html> 
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>CSS</title>
    <link rel="stylesheet" href="style.css">
  </head>

  <body>
    <h1>Make this heading Magenta and give it a Magenta glow using the text-shadow property.</h1>
    <p>Change all typography in the body to the 'Courier New' font.</p>
    <p>Give the body a dark background colour</p>
    <p>Make all paragraphs Aquamarine.</p>
    <p>Make <a href="https://www.w3.org/">this link</a> another colour using a hexidecimal value.</p>
  </body>
</html>`,
  "/style.css": 
  `body {
  
  }

  h1 {
  
  }

  p {
  
  }

  a {
  
  }`,
    "/solution.css": 
  `body {
    font-family: "Courier New", Courier, monospace;
    background: darkslateblue;
  }

  h1 {
    color: magenta;
    text-shadow: 0 0 12px magenta;
  }

  p {
    color: aquamarine;
  }

  a {
    color: #00ffff;
  }
`
  }}
        template="static"
        theme="dark"
        options={{ showLineNumbers: true, activeFile: "/style.css", }}
      />
</div>

## Compound selectors/Selector lists

Once you have a grasp on the three main selector types, you can start
blending them together (Compound selectors) and selecting compounding
type and class selectors, within a selector list:

This solely targets paragraph and span elements which have the special class.

```css
p.special, span.special {
  color: orange;
  font-weight: bold; 
}
```

```html
<p class="special">this text looks very <span class="special">special!</span></p>
<h1 class="special">this text doesn't look special at all, because h1 isn't on the selector list for the .special class</h1>
```

## Combinators: styling by location

- There are times you may want to target something based on where it is
within your HTML structure.
- Using combinators, we can combine multiple selectors to explicitly
target an element based on where it is in relation to another element.
- Selectors using combinators are called Complex Selectors.
- There are many different types of combinator, and you can use multiple
combinators at once!

```css
// Decendant combinator
article p { color: rebeccapurple; }

// Next-sibling combinator
h1+p { font-size: 200%; }

// Child combinator
section > article { font: Montserrat; }

// Subsequent-sibling combinator
p~img { width: relative; }
```

## Pseudo-classes: styling by state
We can also target elements based on their current state, or on a number
of other external factors (e.g. browser history, time, etc.).

A great example of this is styling links. The anchor
`<a>` element has different states:

- Unvisited
- Visited
- Hovered over
- Focused by the keyboard
- Being clicked

We call these selectors pseudo-classes.

```css
a:link { color: pink } 
a:visited { color: green; }
a:hover { text-decoration: underline; }
```


## Selectors
| Selector | Description | Example |
|----------|-------------|---------|
| Type Selector | Targets all relevant HTML elements. | `h1 {}` |
| Class Selector | Targets elements based on the Class attribute. | `.box {}` |
| ID Selector | Targets element with specific ID value. | `#unique {}` |
| Attribute Selector | Makes selection based on if an element has a specific attribute/an attribute value. | `a[title] {}`<br/>`a[href='www.wikipedia.com'] {}` |
| Pseudo-classes | Selects elements that are in a specific state. | `a:hover {}` |
| Pseudo-elements | Selects a very specific part of an element. | `p::first-line {}` |
| Universal Selector | Selects all elements. | `* {}` |
| Combinators | Combines other selectors to target elements. | `#myId > .myClass + p::first-line {}` |

## Combinators
| Combinator | Description | Example |
|------------|-------------|---------|
| Next-sibling combinator | Separates two selectors and targets instances where the second element immediately follows the first. | `h1+p {}` |
| Subsequent sibling combinator | Separates two selectors and targets all instances of the second element following the first, provided they are at the same hierarchy level. | `h2~span {}` |
| Descendant combinator | Separates two selectors. Targets all instances of the second element when nested inside the first. | `section img{}` |
| Child combinator | Separates two selectors and targets instances where the second element is a direct child of the first. | `div > span {}` |

## Specificity
But what happens when two selectors select the same HTML element? Can
anyone guess what colour the text will end up being?

```css
.special { color: red; }
p { color: blue; }
```

### Inline > ID > Class > Type
- Luckily, CSS has in-built rules that decide which selector comes out
on top in the event of a conflict.
- Class selectors will always beat out element type selectors; ID
selectors will always beat out both.
- Inline styling using the style= attribute in HTML will beat all of
them.
- This is what we call the Specificity rule.

So in our example, according to specificity, the text will be red, as
the rules for the class selector beat the element selector.

But what if we have two selectors of the same specificity in conflict?

```css
p { color: red; }
p { color: blue; }
```

Here, we have two rules for `<p>`. So which colour will
our text be this time?

<details>
  <summary><strong>Reveal Answer</strong></summary>
  Anyone who guessed blue: congratulations! The text would be blue because the declaration for blue comes later in the stylesheet.
  This rule is called the Cascade rule - basically, the latest rule in conflict overwrites the others.
</details>

## Selector Specificity
| Weight Category | Selectors | Weighting |
|-----------------|-----------|-----------|
| ID | ID Selectors (`#id`) | 100 |
| Class | Class Selectors (`.class`)<br/>Attribute Selectors (`[attribute="..."]`)<br/>Pseudo-classes (`:pseudo-class`) | 10 |
| Type | Element Type Selectors (`p, h1, img`)<br/>Pseudo-elements (`::pseudo-element`) | 1 |
| No value | Universal Selector `*`<br/>Combinators `+, >, ~, \|, \|\|, â£` | 0 |

Almost all selectors have their own level of specificity you can use to calculate which will win out in a clash.

It's worth noting that an infinite number of selectors in one weight category cannot surpass even a single selector of a higher weight category. 100 class selectors will always be lower priority than 1 ID selector.

| Selector | IDs | Classes | Elements | Total |
|----------|-----|---------|----------|-------|
| `h1` | 0 | 0 | 1 | 001 |
| `h1+p::first-letter` | 0 | 0 | 2 | 002 |
| `li>button[aria-expanded="true"] .button-icon` | 0 | 2 | 2 | 022 |
| `#identifier` | 1 | 0 | 0 | 100 |
| `button:not(#mainBtn, .cta)` | 1 | 0 | 1 | 101 |

All this can get quite confusing when you start using complex selectors. The above table shows a way to track specificity that might be helpful.

A CSS reference guide will provide details on a selector's specificity, and any unique quirks it might have - the :not() pseudo-class used here is a very odd character!

Remember: the Universal selector (*), combinators, and a few pseudo-classes have no effect on specificity.

## Inheritance

```css
p { color: green; }
```
```html
<p>this paragraph has <em>emphasised text</em></p>
```

Also significant here is the concept of inheritance - some CCS
properties cause child elements to inherit the properties of the
parent element by default.

You don't need to be an expert on this yet, but it can cause
unexpected behaviour in your styling. So if things aren't looking
quite right, it might be an inheritance issue.

## Understanding the Cascade

1. **Relevance:** User agent finds all rule blocks with a selector match for each element.
2. **Importance:** Sorts rules based on whether they are Normal, or Important. Important styles are those with the !important flag.
3. **Style Origin:** Within each of the two importance options, sorts CSS rules by whose stylesheet they're in: the user-agent, the author (developer), or the website user. Priority differs based on these answers, combined with the importance rule.
4. **Cascade Layers:** Within these six categories, sorts rules again by Cascade Layer. Cascade layers are a tool devs use to add extra sub-layers of priority to stylesheets.
5. **Specificity:** Sorts rules by specificity of selectors, as we have explored.
6. **Scoping Proximity:** This helps resolve conflicts between declarations within a @scope. @scope sets very specific conditions for when a CSS rule should be applied.
7. **Source Order:** When two selectors in the same origin & cascade layers have the same importance, specificity, and scope proximity, the last declared selector wins.
8. **Relevance:** User agent finds all rule blocks with a
selector match for each element.

We've talked about selector specificity and the order selectors are
declared in, but these are only two steps in a much larger process web
browsers go through to decide which CSS rules are applied.

User-agents follow the steps on the left from 1-7: only rules 'still in
the running' each time move to the next step. Once there is only one
left, no more rules are checked.

You don't have to understand all these concepts right now - just know
they exist, so that you can spot them in other people's CSS.

## Style Origin
1. normal user-agent styles
2. normal user styles
3. normal author styles
4. styles being animated
5. important author styles
6. important user styles
7. important user-agent styles
8. styles being transitioned

As we've seen, the origin of style rules can greatly impact their level of specificity in the cascade order.

The user-agent has the lowest priority with regard to normal styles, but one of the highest when styles are !important.

Users of your site may also be applying their own styles to your page (think Chrome Extensions, for instance.) Their styles are of medium importance for both normal and !important buckets.

It's useful to know this so you know how your styles (author styles) fit into this origin order.

## What is the Box Model?
Everything in CSS has a box around it.

These boxes have several properties which will affect how they are laid
out on our webpage, and how they interact with other elements.

Boxes have an Outer display type and an Inner display type:

- Outer display controls how the element sits on the page alongside other elements
- Inner display controls the layout of everything within the box - including any nested elements.

We can set these display types using the display property.

### The Box Model: Outer display type
Outer display type controls the flow layout of elements on the page.

**When this is set to `block`:**

- The box will break onto a new line.
- Width & height properties are respected. If no width is given, the box will extend to fill its containing element.
- Padding, margins & borders will cause other elements to be pushed away from the box.
- Some elements, like `<h1>` and `<p>`, use block as their outer display type by default.


**When this is set to `inline`:**
- The box will not break onto a new line.
- Width & height properties will not apply.
- Top & bottom padding, margins, & borders will not push other inline elements away.
- Left & right padding/margins/borders will still push other inline elements away.
- HTML elements, such as `<a>`, `<span>`, `<em>` and `<strong>` use inline as their default outer display type.

### The Standard Box Model

CSS boxes are made up of four main parts:

- Content
- Padding
- Border
- Margin

In the standard CSS box model, when you set the width and height properties on a box, these values apply only to the content section of your CSS box.

properties on a box, these values apply only to the content section of your CSS box.

Any padding & borders are then added on top of these dimensions to get
the total size taken up by the box. Margins do not count!

The box model only applies fully to block boxes. Inline boxes do adopt some features, but not all of them!

```css
.box {
  width: 350px;
  height: 150px;
  margin: 10px;
  padding: 25px;
  border: 5px solid black;
}
```

Looking at this CSS, what would the size of our CSS box actually be?

## Margins

```css
.box { margin: 10px -5px 10px 20px; } 

.axis-based {
  margin: 20px 30px;
}

.longhand {
  margin-top: 10px; 
  margin-right: -5px;
  margin-bottom: 10px; 
  margin-left: 20px; 
}
```
- Margins are the invisible space around your box, which pushes other elements away from it.
- They can have positive and negative values; setting a negative value causes your box to overlap with other elements on the page.
- Remember - margins don't count towards box size!
- Control all margins of an element at once using the margin property, or control each side using longhand.
 

### Margin Collapsing

- Depending on whether two elements whose margins touch have positive or negative margins, you will get different results.
- This is the result of something called Margin Collapse.
- Two positive margins will collapse to become one margin - the biggest value margin.
- Two negative margins will collapse, with the smallest value being used.
- If only one margin is negative, it will be subtracted from the other.
- There's a lot of rules surrounding margin collapse - your reference guide can help if your boxes aren't looking the way you expect.


### Borders

```css
.box {
  border: 5px solid blue;
}
.longhand {
  border-top-width: 2px;
  border-bottom-style: dotted;
  border-left-color: orange;
}
```

## Borders
- Borders are drawn between the margin and the padding of a box.
- There are a large number of properties available for styling borders, as each side has its own width, style, and colour properties.
- You can use the border property to change all these values at once, or use longhand to apply more specific styling.

## Padding

```css
.box { 
  padding: 7px 7px 10px 10px;
} 

.longhand {
  padding-top: 7px; 
  padding-bottom: 7px; 
  padding-left: 10px; 
  padding-right: 10px;
}
```

- Padding sits between the border and the content area and is used to push the content away from the border.
- There is no negative value for padding; the lowest possible value is 0.
- Any background applied to your element will display behind the padding.
- Like margins and borders, there's long and shorthand for padding.

## The Alternate Box Model

- When using the alternative box model, width & height properties affect the whole visible box on the page.
- Any border and padding values you then set are subtracted from the total width & height, leaving the size value of your content.
- This can be useful if you have very specific dimensions your box cannot exceed.
- You can switch to the alternate box model in CSS by using the property `box-sizing: border-box;`

```css
html {
  box-sizing: border-box;
}
*, *::before, *::after {
  box-sizing: inherit;
}
```

- Developers often like to use the alternate box model for all their elements.
- To do that, we set the `box-sizing` property on the `<html>` element.
- We then use the universal selector to ensure all our elements inherit that value from the HTML element.

## Display: inline-block;

- `display: inline-block` is a special value of display, which provides a middle ground between inline and block.
- Use it if you don't want an item to break onto a new line, but you do want it to respect width & height.
- This also avoids the overlapping you often see in a purely inline layout.

## Sizing Content

```css
.box {
  display: block;
  border: 5px solid red;
  padding: 2em;
  width: 50%;
}
```

- We've mostly been sizing content so far using the pixel measurement (px).
- Using absolute values can often end with content overflowing from their boxes.
- We can instead use relative values to set the size of an element. The element will then be sized to a percentage of its parent element.
- When no percentage is set, a block element will take up 100% of available width. So a percentage value may make it more responsive to different screens.

## Styling Images

 
**object-fit: contain;**

- shrinks to fit box on longest side
- maintains aspect ratio
- results in 'letterboxing'

**object-fit: cover;**

- crops to fit box on shortest side
- maintains aspect ratio
- does not contain whole image

**object-fit: fill;**

- resizes to fit box on both sides
- does not maintain aspect ratio

Whilst CSS can't affect the internal layout of an image or video, we
can adjust how they are laid out on the page.

If we try to place an image inside a CSS box that isn't the same size
as the image:

- The image will not stretch to fit a larger box
- The image will overflow out of a smaller box.
  
We can use the `object-fit` property to ensure our image completely covers our box.

## At-rules: Importing Fonts

```css
@font-face {
  font-family: "MyHelvetica";
  src: local("Helvetica Neue Bold"),
       local("HelveticaNeue-Bold"),
       url("MgOpenModernaBold.ttf");
  font-weight: bold;
}
```

- At-rules in CSS are specific instructions we can give on how we want CSS to behave. We declare an at-rule by using @.
- The rule then lasts until the next ; on its hierarchy level, or the next CSS block - whichever comes first.
- We can use the `@font-face` rule to import custom fonts for our text: either from our own locally-installed fonts, or from external sources.
- Adding both a local and url source allows for a backup option should the user not have that font installed!


## At-rules: Cascade Layers

```css
/* Layer order */
@layer reset, base, layout;

/* Layer styles */
@layer reset {
/* apply a natural box layout model to all elements, but allowing components to change */
  html {
    box-sizing: border-box;
  }
  *, *:before, *:after {
    box-sizing: inherit;
  }
}

@layer base {
  body {
    display: inline-block;
    font: bold 12px/20px Montserrat blue;
  }
  a {
     color: rebeccapurple;
  }
}

@layer layout {
  #site-header .container {
    display: flex;
    align-items: center;
    justify-content: space-between;
  }
}

/* Styles with no layer take priority */
a {
  color: cornflowerblue;
}
```
      
- Another great use of at-rules is for the creation of Cascade Layers.
- We talked a little bit before about CSS layers in relation to the cascade - they allow us to create added layers of specificity into our stylesheet.
- There's a few ways to go about adding layers - our example is the `@layer` block at-rule, which creates a block for that layer which you can add styles into.
- The order of layer creation is important, as it affects the level of hierarchy amongst layers. Your reference guide should be able to explain more about this.
