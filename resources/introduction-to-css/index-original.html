<!DOCTYPE html>
<html lang="en-GB">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Introduction to CSS | CTL Norwich</title>

    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/kelpui@1/css/kelp.css"
    />

    <link
      href="https://cdn.jsdelivr.net/npm/prismjs-okaidia-theme@0.0.1/prism-okaidia.min.css"
      rel="stylesheet"
    />

    <link
      href=" https://cdn.jsdelivr.net/npm/prismjs@1.3.0/plugins/line-highlight/prism-line-highlight.css"
      rel="stylesheet"
    />

    <script
      type="module"
      src="https://cdn.jsdelivr.net/npm/kelpui@1/js/kelp.js"
    ></script>

    <script
      src="https://cdn.jsdelivr.net/npm/kelpui@1/js/dark-mode-auto.js"
      defer
    ></script>

    <script type="module">
      import prismjs from "https://cdn.jsdelivr.net/npm/prismjs@1.30.0/+esm";
    </script>

    <script
      src="https://cdn.jsdelivr.net/npm/prismjs@1.3.0/plugins/line-highlight/prism-line-highlight.min.js"
      defer
    ></script>

  </head>

  <body class="flex direction-column">
    <main class="container">

      <h1 class="margin-start-m">CSS: Style the Web</h1>

      <section class="callout primary">
        <h2>Objectives</h2>
        <ol>
          <li>Get started with styling</li>
          <li>Get started with styling</li>
          <li>CSS selectors</li>
          <li>CSS structures</li>
          <li>The box Model</li>
          <li>Other CSS basics</li>
        </ol>
      </section>

      <h2>What is CSS?</h2>

      <p>
        Cascading Style Sheets (CSS) is a language used to describe the design
        and layout of a HTML or XML document. It dictates how elements should be
        presented - whether that's on-screen, in print, in speech, or in other
        media types.
      </p>
      <p>
        Like HTML, CSS is a Declarative Language used for Frontend Development.
      </p>
      <p>
        Also like HTML, CSS no longer has a unified release version. After CSS
        2.1, it was decided that CSS would be updated as multiple separate
        modules, rather than all at once. The core CSS syntax is currently on
        Level 3, whilst the color module is on level 5! We call this a living
        standard language.
      </p>
      <p>
        The development of CSS is overseen by the World Wide Web Consortium
        (W3C).
      </p>

      <h2>The CSS file</h2>

      <ul>
        <li>
          Whilst you can style elements within the <code>&lt;head&gt;</code> of
          your HTML, it's much better practice to make a separate CSS file in VS
          Code.
        </li>
        <li>
          Create a new file in the
          <strong>Build your own Stylesheet</strong> folder in VS Code and call
          it <code>style.css</code>.
        </li>
        <li>
          We can then head to the <code>index.html</code> file, and add a
          <code>&lt;link&gt;</code> to our stylesheet.
        </li>
        <li>
          You can add in a sub-folder for your CSS if you like things tidy! Just
          remember to put the right file path in your <code>&lt;link&gt;</code>.
        </li>
      </ul>

      <pre><code class="language-html">&lt;link rel="stylesheet" href="style.css"&gt;</code></pre>

      <h2>CSS Syntax</h2>

      <p>
        CSS is comprised of three main parts: Selectors, Properties, and Values.
      </p>
      <p>
        These look slightly different depending on whether you're using inline
        CSS or internal/external CSS.
      </p>

      <h3>Inline CSS</h3>
      <pre><code class="language-html">&lt;p style="color:green; font-style:italic;"&gt;This is a paragraph.&lt;/p&gt;</code></pre>

      <h3>Internal/External CSS</h3>
      <pre><code class="language-css">p {color: green; font-style: italic;}</code></pre>

      <h2>CSS Syntax</h2>

      <pre><code class="language-css">body {
 font-family: Open Sans, Arial; 
 color: #000000;
 font-size: 9px;
 background: #ffffff;
 line-height: 16px;
}</code></pre>

      <ul>
        <li>
          CSS is a rules-based language; we define the styling rules by picking
          out groups of elements and declaring style properties for them.
        </li>
        <li>
          We start with a Selector - this tells our browser which elements these
          style rules apply to.
        </li>
        <li>
          We then add in declarations, which are made up of Properties and
          Values - what style aspect we want to change, and what we want to
          change it to.
        </li>
        <li>Only properties inside the curly braces will be changed!</li>
      </ul>

      <h2>Colo(u)r in CSS</h2>

      <pre><code class="language-css">color: CornflowerBlue;
color: #af0f9d;
color: rgba(255, 99, 71, 0.9);
color: hsl(85, 88%, 51%);</code></pre>

      <ul>
        <li>
          There's a few ways we can define colour in CSS - which you choose to
          use might depend on the kind of colour you need.
        </li>
        <li>
          The simplest way is by just typing in a colour name. CSS has ~140
          inbuilt colours to choose from.
        </li>
        <li>
          You can also use a colour hex code. For example,
          <code>#000000</code> is black, whilst <code>#ffffff</code> is white.
        </li>
        <li>
          If you need to control opacity, try using
          <code>rgba(255,255,255,1)</code>. This allows you to set red, green,
          blue and alpha values.
        </li>
        <li>
          You could also opt for <code>hsl(180,61%,100%)</code> which will
          adjust hue, saturation, and lightness.
        </li>
      </ul>

      <h2>CSS Referencing</h2>

      <p>
        There are a huge number of different CSS properties - more than we could
        ever cover.
      </p>
      <p>
        An important part of any developer toolkit is a reference guide for the
        language you're working with. Learning how to use a reference guide is
        the most valuable thing you can do!
      </p>
      <p>
        It may be tempting to try and ask AI for the answer - avoid this if you
        can, especially for living standard languages that are updated
        regularly. AI training data is often years out of date, and won't always
        provide a reliable answer.
      </p>
      <p>Trust your own brain! You are smart!</p>

      <ul>
        <li>
          <a href="https://www.w3.org/Style/CSS/Overview.en.html"
            >W3C CSS overview</a
          >
        </li>
        <li>
          <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Reference"
            >MDN CSS guide</a
          >
        </li>
        <li><a href="https://web.dev/learn/css">web.dev CSS guide</a></li>
      </ul>

      <h2>CSS Selectors: the Big Three</h2>

      <p>
        As we've seen, CSS rules always start with a Selector - or a list of
        selectors. There are quite a few types of selector, but the you'll use
        the most are:
      </p>

      <dl>
        <dt>Type selector</dt>
        <dd>
          <ul>
            <li>
              Selects elements solely by the element tag name, e.g.
              <code>h1</code>, <code>img</code>, <code>a</code>, etc.
            </li>
            <li>
              All elements of this type in HTML will be selected for styling.
            </li>
            <li>The simplest selector type.</li>
          </ul>
        </dd>

        <dt>Class selector</dt>
        <dd>
          <ul>
            <li>
              Selects elements by Class - an attribute you can give multiple
              elements in HTML.
            </li>
            <li>All elements with the same Class name will be selected.</li>
            <li>
              Can be used to select multiple similar elements without having to
              select all of them.
            </li>
          </ul>
        </dd>

        <dt>ID selector</dt>
        <dd>
          <ul>
            <li>
              Selects a HTML element for styling by referencing the ID
              attribute.
            </li>
            <li>
              Only one HTML element will be selected, since IDs should be
              unique.
            </li>
            <li>
              Used to make style changes to one element without changing the
              others.
            </li>
          </ul>
        </dd>
      </dl>

      <h2>CSS Type Selectors</h2>
      <pre><code class="language-css">h1 {
  font: bold 12px/20px Montserrat; 
  text-align: left;
  text-transform: uppercase; 
  mix-blend-mode: overlay; 
  letter-spacing: 2px;
}</code></pre>

      <pre><code class="language-html">&lt;h1&gt;welcome to my website!&lt;/h1&gt;</code></pre>

      <h2>CSS Class Selectors</h2>
      <pre><code class="language-css">.quote { 
  text-align: center;
  font-size: 13px;
  font-style: italic; 
}
</code></pre>
      <pre><code class="language-html">&lt;h1 class="quote"&gt;welcome to my website!&lt;/h1&gt;</code></pre>

      <h2>Multiple Classes</h2>

      <p>
        The example before used only one class name for the element. But if
        every HTML element could only belong to a single class, that would
        create a lot of work for us!
      </p>
      <p>
        Luckily, HTML allows us to stack class attributes and apply multiple
        style rules at once:
      </p>

      <pre><code class="language-css">.green { color: green; }
.bold { font-weight: bold; }
</code></pre>

      <pre><code class="language-html">&lt;h1 class="green bold"&gt;Hello World!&lt;/h1&gt;</code></pre>

      <h2>CSS ID Selectors</h2>

      <pre><code class="language-css">#sidebar {
  width: 400px;
  height: 100%;
  position: fixed;
  top: 0;
  left: 0;
  display: table;
  background: url(”galaxy.jpg"); 
  background-size: cover; 
  color: #000000;
}
</code></pre>

      <pre><code class="language-html">&lt;section id="sidebar"&gt;
  &lt;h1&gt;Welcome to my site!&lt;/h1&gt;
&lt;/section&gt;</code></pre>

      <h2>CSS Selectors: Practical</h2>
      <p>In your new style.css file, add the following style rules:</p>
      <ul>
        <li>
          Change all elements in <code>&lt;body&gt;</code> to use the Helvetica
          font stack. The property you will need is:
          <code>font-family: Helvetica, Arial, Sans-Serif;</code>
        </li>
        <li>
          Style only the <code>&lt;p&gt;</code> elements in the header and
          footer to be CornFlowerBlue.
        </li>
        <li>
          Give one element in the page an ID, then use a reference guide to
          choose 2 new properties and apply them to your selected element.
        </li>
      </ul>

      <h2>Compound selectors/Selector lists</h2>
      <p>
        Once you have a grasp on the three main selector types, you can start
        blending them together (Compound selectors) and selecting compounding
        type and class selectors, within a selector list:
      </p>

      <p>
        This solely targets paragraph and span elements which have the special
        class.
      </p>

      <pre><code class="language-css">p.special, span.special {
  color: orange;
  font-weight: bold; 
}
</code></pre>

      <pre><code class="language-html">&lt;p class="special"&gt;this text looks very &lt;span class="special"&gt;special!&lt;/span&gt;&lt;/p&gt;
&lt;h1 class="special"&gt;this text doesn't look special at all, because h1 isn't on the selector list for the .special class&lt;/h1&gt;</code></pre>

      <h2>Combinators: styling by location</h2>

      <p>
        There are times you may want to target something based on where it is
        within your HTML structure.
      </p>
      <p>
        Using combinators, we can combine multiple selectors to explicitly
        target an element based on where it is in relation to another element.
      </p>
      <p>Selectors using combinators are called Complex Selectors.</p>
      <p>
        There are many different types of combinator, and you can use multiple
        combinators at once!
      </p>

      <dl>
        <dt>Descendant combinator</dt>
        <dd>
          <pre><code class="language-css">article p { color: rebeccapurple; }</code></pre>
        </dd>

        <dt>Next-sibling combinator</dt>
        <dd>
          <pre><code class="language-css">h1+p { font-size: 200%; }</code></pre>
        </dd>

        <dt>Child combinator</dt>
        <dd>
          <pre><code class="language-css">section > article { font: Montserrat; }</code></pre>
        </dd>

        <dt>Subsequent-sibling combinator</dt>
        <dd>
          <pre><code class="language-css">p~img { width: relative; }</code></pre>
        </dd>
      </dl>

      <h2>Pseudo-classes: styling by state</h2>

      <p>
        We can also target elements based on their current state, or on a number
        of other external factors (e.g. browser history, time, etc.).
      </p>
      <p>
        A great example of this is styling links. The anchor
        <code>&lt;a&gt;</code> element has different states:
      </p>
      <ul>
        <li>Unvisited</li>
        <li>Visited</li>
        <li>Hovered over</li>
        <li>Focused by the keyboard</li>
        <li>Being clicked</li>
      </ul>
      <p>We call these selectors pseudo-classes.</p>

      <pre><code class="language-css">a:link { color: pink } 
a:visited { color: green; }
a:hover { text-decoration: underline; }
</code></pre>

      <dl>
        <dt>Type Selector</dt>
        <dd>Targets all relevant HTML elements. <br /><code>h1 {}</code></dd>

        <dt>Class Selector</dt>
        <dd>
          Targets elements based on the Class attribute. <br /><code
            >.box {}</code
          >
        </dd>

        <dt>ID Selector</dt>
        <dd>
          Targets element with specific ID value. <br /><code>#unique {}</code>
        </dd>

        <dt>Attribute Selector</dt>
        <dd>
          Makes selection based on if an element has a specific attribute/an
          attribute value. <br /><code
            >a[title] {}<br />a[href='www.wikipedia.com'] {}</code
          >
        </dd>

        <dt>Pseudo-classes</dt>
        <dd>
          Selects elements that are in a specific state. <br /><code
            >a:hover {}</code
          >
        </dd>

        <dt>Pseudo-elements</dt>
        <dd>
          Selects a very specific part of an element. <br /><code
            >p::first-line {}</code
          >
        </dd>

        <dt>Universal Selector</dt>
        <dd>Selects all elements. <br /><code>* {}</code></dd>

        <dt>Combinators</dt>
        <dd>
          Combines other selectors to target elements. <br /><code
            >#myId > .myClass + p::firstline {}</code
          >
        </dd>
      </dl>

      <h3>Combinators</h3>

      <dl>
        <dt>Next-sibling combinator</dt>
        <dd>
          Separates two selectors and targets instances where the second element
          immediately follows the first.
          <br /><code>h1+p {}</code>
        </dd>

        <dt>Subsequent sibling combinator</dt>
        <dd>
          Separates two selectors and targets all instances of the second
          element following the first, provided they are at the same hierarchy
          level.
          <br /><code>h2~span {}</code>
        </dd>

        <dt>Descendant combinator</dt>
        <dd>
          Separates two selectors. Targets all instances of the second element
          when nested inside the first.
          <br /><code>section img{}</code>
        </dd>

        <dt>Child combinator</dt>
        <dd>
          Separates two selectors and targets instances where the second element
          is a direct child of the first.
          <br /><code>div > span {}</code>
        </dd>

        <dt>Column combinator</dt>
        <dd>
          Targets elements which belong to a column <code>&lt;col&gt;</code>.
          Used mostly for table styling. <br /><code>col||td{}</code>
        </dd>

        <dt>Namespace separator</dt>
        <dd>
          Targets elements belonging to a specified <code>@namespace</code> - a
          tool used when your page contains multiple languages (e.g. HTML with
          inline SVG) <br /><code>@myNameSpace | p {}</code>
        </dd>
      </dl>

      <h2>Specificity</h2>

      <p>
        But what happens when two selectors select the same HTML element? Can
        anyone guess what colour the text will end up being?
      </p>

      <h3>CSS</h3>
      <pre><code class="language-css">.special { color: red; }
p { color: blue; } </code></pre>

      <pre><code class="language-markup">&lt;p class="special"&gt;hello&lt;/p&gt;</code></pre>

      <h3>Inline > ID > Class > Type</h3>

      <ul>
        <li>
          Luckily, CSS has in-built rules that decide which selector comes out
          on top in the event of a conflict.
        </li>
        <li>
          Class selectors will always beat out element type selectors; ID
          selectors will always beat out both.
        </li>
        <li>
          Inline styling using the style= attribute in HTML will beat all of
          them.
        </li>
        <li>This is what we call the Specificity rule.</li>
      </ul>

      <p>
        So in our example, according to specificity, the text will be red, as
        the rules for the class selector beat the element selector. But what if
        we have two selectors of the same specificity in conflict?
      </p>

      <pre><code class="language-css">.special { color: red; }
p { color: blue; }</code></pre>

      <pre><code class="language-markup">&lt;p class="special"&gt;hello&lt;/p&gt;</code></pre>

      <pre><code class="language-css">p { color: red; }
p { color: blue; }</code></pre>

      <p>
        Here, we have two rules for <code>&lt;p&gt;</code>. So which colour will
        our text be this time?
      </p>

      <details>
        <summary><strong>Reveal Answer</strong></summary>
        <ul>
          <li>Anyone who guessed blue: congratulations!</li>
          <li>
            The text would be blue because the declaration for blue comes later
            in the stylesheet.
          </li>
          <li>
            This rule is called the Cascade rule - basically, the latest rule in
            conflict overwrites the others.
          </li>
        </ul>
      </details>

      <h2>Selector Specificity</h2>

      <table>
        <thead>
          <tr>
            <th>Weight Category</th>
            <th>Selectors</th>
            <th>Weighting</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>ID</td>
            <td>ID Selectors (<code>#id</code>)</td>
            <td>100</td>
          </tr>
          <tr>
            <td>Class</td>
            <td>
              Class Selectors (<code>.class</code>)<br />Attribute Selectors (
              <code>[attribute="..."]</code> )<br />Pseudo-classes
              (<code>:pseudo-class</code>)
            </td>
            <td>10</td>
          </tr>
          <tr>
            <td>Type</td>
            <td>
              Element Type Selectors (<code>p, h1, img</code
              >)<br />Pseudo-elements (<code>::pseudo-element</code>)
            </td>
            <td>1</td>
          </tr>
          <tr>
            <td>No value</td>
            <td>
              Universal Selector (<code>*</code>)<br />Combinators (<code
                >+, >, ~, |, ||, ␣</code
              >)
            </td>
            <td>0</td>
          </tr>
        </tbody>
      </table>

      <p>
        Almost all selectors have their own level of specificity you can use to
        calculate which will win out in a clash.
      </p>
      <p>
        It's worth noting that an infinite number of selectors in one weight
        category cannot surpass even a single selector of a higher weight
        category. 100 class selectors will always be lower priority than 1 ID
        selector.
      </p>

      <table>
        <thead>
          <tr>
            <th>Selector</th>
            <th>IDs</th>
            <th>Classes</th>
            <th>Elements</th>
            <th>Total</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>h1</code></td>
            <td>0</td>
            <td>0</td>
            <td>1</td>
            <td>001</td>
          </tr>
          <tr>
            <td><code>h1+p::first-letter</code></td>
            <td>0</td>
            <td>0</td>
            <td>2</td>
            <td>002</td>
          </tr>
          <tr>
            <td><code>li>a[href="my-link"] > .inline-warning</code></td>
            <td>0</td>
            <td>2</td>
            <td>2</td>
            <td>022</td>
          </tr>
          <tr>
            <td><code>#identifier</code></td>
            <td>1</td>
            <td>0</td>
            <td>0</td>
            <td>100</td>
          </tr>
          <tr>
            <td><code>button:not(#mainBtn, .cta)</code></td>
            <td>1</td>
            <td>0</td>
            <td>1</td>
            <td>101</td>
          </tr>
        </tbody>
      </table>

      <p>
        All this can get quite confusing when you start using complex selectors.
        The above table shows a way to track specificity that might be helpful.
      </p>
      <p>
        A CSS reference guide will provide details on a selector's specificity,
        and any unique quirks it might have - the :not() pseudo-class used here
        is a very odd character!
      </p>

      <p>
        Remember: the Universal selector (*), combinators, and a few pseudo-
        classes have no effect on specificity.
      </p>

      <h2>Inheritance</h2>

      <pre><code class="language-css">p { color: green; }</code></pre>

      <pre><code class="language-html">&lt;p&gt;this paragraph has &lt;em&gt;emphasised text&lt;/em&gt;&lt;/p&gt;</code></pre>

      <ul>
        <li>
          Also significant here is the concept of inheritance - some CCS
          properties cause child elements to inherit the properties of the
          parent element by default.
        </li>
        <li>
          You don't need to be an expert on this yet, but it can cause
          unexpected behaviour in your styling. So if things aren't looking
          quite right, it might be an inheritance issue.
        </li>
      </ul>

      <h2>Understanding the Cascade</h2>

      <ol>
        <li>
          <strong>Relevance:</strong> User agent finds all rule blocks with a
          selector match for each element.
        </li>
        <li>
          <strong>Importance:</strong> Sorts rules based on whether they are
          Normal, or Important. Important styles are those with the !important
          flag.
        </li>
        <li>
          <strong>Style Origin:</strong> Within each of the two importance
          options, sorts CSS rules by whose stylesheet they're in: the
          user-agent, the author (developer), or the website user. Priority
          differs based on these answers, combined with the importance rule.
        </li>
        <li>
          <strong>Cascade Layers:</strong> Within these six categories, sorts
          rules again by Cascade Layer. Cascade layers are a tool devs use to
          add extra sub-layers of priority to stylesheets.
        </li>
        <li>
          <strong>Specificity:</strong> Sorts rules by specificity of selectors,
          as we have explored.
        </li>
        <li>
          <strong>Scoping Proximity:</strong> This helps resolve conflicts
          between declarations within a @scope. @scope sets very specific
          conditions for when a CSS rule should be applied.
        </li>
        <li>
          <strong>Source Order:</strong> When two selectors in the same origin &
          cascade layers have the same importance, specificity, and scope
          proximity, the last declared selector wins.
        </li>
      </ol>

      <p>
        We've talked about selector specificity and the order selectors are
        declared in, but these are only two steps in a much larger process web
        browsers go through to decide which CSS rules are applied.
      </p>
      <p>
        User-agents follow the steps on the left from 1-7: only rules 'still in
        the running' each time move to the next step. Once there is only one
        left, no more rules are checked.
      </p>
      <p>
        You don't have to understand all these concepts right now - just know
        they exist, so that you can spot them in other people's CSS.
      </p>

      <h2>Style Origin</h2>

      <ol>
        <li>normal user-agent styles</li>
        <li>normal user styles</li>
        <li>normal author styles</li>
        <li>styles being animated</li>
        <li>important author styles</li>
        <li>important user styles</li>
        <li>important user-agent styles</li>
        <li>styles being transitioned</li>
      </ol>

      <p>
        As we've seen, the origin of style rules can greatly impact their level
        of specificity in the cascade order.
      </p>
      <p>
        The user-agent has the lowest priority with regard to normal styles, but
        one of the highest when styles are !important.
      </p>
      <p>
        Users of your site may also be applying their own styles to your page
        (think Chrome Extensions, for instance.) Their styles are of medium
        importance for both normal and !important buckets.
      </p>
      <p>
        It's useful to know this so you know how your styles (author styles) fit
        into this origin order.
      </p>

      <h2>What is the Box Model?</h2>

      <p>Everything in CSS has a box around it.</p>
      <p>
        These boxes have several properties which will affect how they are laid
        out on our webpage, and how they interact with other elements.
      </p>
      <p>Boxes have an Outer display type and an Inner display type:</p>
      <ul>
        <li>
          Outer display controls how the element sits on the page alongside
          other elements
        </li>
        <li>
          Inner display controls the layout of everything within the box -
          including any nested elements.
        </li>
      </ul>
      <p>We can set these display types using the display property.</p>

      <h3>The Box Model: Outer display type</h3>

      <p>
        Outer display type controls the flow layout of elements on the page.
      </p>

      <p><strong>When this is set to block:</strong></p>

      <ul>
        <li>The box will break onto a new line.</li>
        <li>
          Width & height properties are respected. If no width is given, the box
          will extend to fill its containing element.
        </li>
        <li>
          Padding, margins & borders will cause other elements to be pushed away
          from the box.
        </li>
        <li>
          Some elements, like <code>&lt;h1&gt;</code> and
          <code>&lt;p&gt;</code>, use block as their outer display type by
          default.
        </li>
      </ul>

      <p><strong>When this is set to inline:</strong></p>

      <ul>
        <li>The box will not break onto a new line.</li>
        <li>Width & height properties will not apply.</li>
        <li>
          Top & bottom padding, margins, & borders will not push other inline
          elements away.
        </li>
        <li>
          Left & right padding/margins/borders will still push other inline
          elements away.
        </li>
        <li>
          HTML elements, such as <code>&lt;a&gt;</code>,
          <code>&lt;span&gt;</code>, <code>&lt;em&gt;</code> and
          <code>&lt;strong&gt;</code> use inline as their default outer display
          type.
        </li>
      </ul>

      <h3>The Standard Box Model</h3>

      <p>CSS boxes are made up of four main parts:</p>
      <ul>
        <li>Content</li>
        <li>Padding</li>
        <li>Border</li>
        <li>Margin</li>
      </ul>
      <p>
        In the standard CSS box model, when you set the width and height
        properties on a box, these values apply only to the content section of
        your CSS box.
      </p>
      <p>
        Any padding & borders are then added on top of these dimensions to get
        the total size taken up by the box. Margins do not count!
      </p>
      <p>
        The box model only applies fully to block boxes. Inline boxes do adopt
        some features, but not all of them!
      </p>

      <h2>The Standard Box Model</h2>
      <pre><code class="language-css">.box {
  width: 350px;
  height: 150px;
  margin: 10px;
  padding: 25px;
  border: 5px solid black;
}
</code></pre>

      <p>
        Looking at this CSS, what would the size of our CSS box actually be?
      </p>

      <h2>Margins</h2>

      <pre><code class="language-css">.box { margin: 10px -5px 10px 20px; } 

.axis-based {
  margin: 20px 30px;
}

.longhand {
  margin-top: 10px; 
  margin-right: -5px;
  margin-bottom: 10px; 
  margin-left: 20px; 
}
</code></pre>

      <h2>Margins</h2>

      <ul>
        <li>
          Margins are the invisible space around your box, which pushes other
          elements away from it.
        </li>
        <li>
          They can have positive and negative values; setting a negative value
          causes your box to overlap with other elements on the page.
        </li>
        <li>Remember - margins don't count towards box size!</li>
        <li>
          Control all margins of an element at once using the margin property,
          or control each side using longhand.
        </li>
      </ul>

      <h2>Margin Collapsing</h2>

      <ul>
        <li>
          Depending on whether two elements whose margins touch have positive or
          negative margins, you will get different results.
        </li>
        <li>This is the result of something called Margin Collapse.</li>
        <li>
          Two positive margins will collapse to become one margin - the biggest
          value margin.
        </li>
        <li>
          Two negative margins will collapse, with the smallest value being
          used.
        </li>
        <li>
          If only one margin is negative, it will be subtracted from the other.
        </li>
        <li>
          There's a lot of rules surrounding margin collapse - your reference
          guide can help if your boxes aren't looking the way you expect.
        </li>
      </ul>

      <h2>Borders</h2>

      <pre><code class="language-css">.box {
  border: 5px solid blue;
}
.longhand {
  border-top-width: 2px;
  border-bottom-style: dotted;
  border-left-color: orange;
}
</code></pre>

      <h2>Borders</h2>

      <ul>
        <li>Borders are drawn between the margin and the padding of a box.</li>
        <li>
          There are a large number of properties available for styling borders,
          as each side has its own width, style, and colour properties.
        </li>
        <li>
          You can use the border property to change all these values at once, or
          use longhand to apply more specific styling.
        </li>
      </ul>

      <h2>Padding</h2>

      <pre><code class="language-css">
.box { 
  padding: 7px;
} 

.longhand {
  padding-top: 7px; 
  padding-bottom: 7px; 
  padding-left: 10px; 
  padding-right: 10px;
}
</code></pre>

      <ul>
        <li>
          Padding sits between the border and the content area and is used to
          push the content away from the border.
        </li>
        <li>
          There is no negative value for padding; the lowest possible value is
          0.
        </li>
        <li>
          Any background applied to your element will display behind the
          padding.
        </li>
        <li>
          Like margins and borders, there's long and shorthand for padding.
        </li>
      </ul>

      <!--
      <h2>Box Model: Practical</h2>

      <p>In your new style.css file, add the following style rules:</p>

      <ul>
        <li>
          Choose a <code>&lt;section&gt;</code> and give it an ID using the ID
          attribute in HTML
        </li>
        <li>
          In your CSS stylesheet, create the following style rules for your
          <code>&lt;section&gt;</code>:
          <ul>
            <li>Set the width of your section to 100% of the page.</li>
            <li>Set the height to 150px.</li>
            <li>
              Give your element a 5px border, in a colour and style of your
              choice.
            </li>
            <li>Add 20px of padding on only the left side of the box.</li>
          </ul>
        </li>
        <li>
          Select the <code>&lt;a&gt;</code> element in CSS and create the
          following rules:
          <ul>
            <li>Set the display type to block.</li>
            <li>Add a margin of 30px on all sides.</li>
          </ul>
        </li>
      </ul>
      -->
      
      <h2>The Alternate Box Model</h2>

      <ul>
        <li>
          When using the alternative box model, width &amp; height properties
          affect the whole visible box on the page.
        </li>
        <li>
          Any border and padding values you then set are subtracted from the
          total width &amp; height, leaving the size value of your content.
        </li>
        <li>
          This can be useful if you have very specific dimensions your box
          cannot exceed.
        </li>
        <li>
          You can switch to the alternate box model in CSS by using the property
          <code>box-sizing: border-box;</code>
        </li>
      </ul>

      <pre><code class="language-css">html {
  box-sizing: border-box;
}
*, *::before, *::after {
  box-sizing: inherit;
}
</code></pre>

      <ul>
        <li>
          Developers often like to use the alternate box model for all their
          elements.
        </li>
        <li>
          To do that, we set the <code>box-sizing</code> property on the
          <code>&lt;html&gt;</code> element.
        </li>
        <li>
          We then use the universal selector to ensure all our elements inherit
          that value from the HTML element.
        </li>
      </ul>

      <h2>Display: inline-block;</h2>

      <ul>
        <li>
          <code>display: inline-block</code> is a special value of display,
          which provides a middle ground between inline and block.
        </li>
        <li>
          Use it if you don't want an item to break onto a new line, but you do
          want it to respect width &amp; height.
        </li>
        <li>
          This also avoids the overlapping you often see in a purely inline
          layout.
        </li>
      </ul>

      <h2>Sizing Content</h2>

      <pre><code class="language-css">.box {
  display: block;
  border: 5px solid red;
  padding: 2em;
  width: 50%;
}
</code></pre>

      <ul>
        <li>
          We've mostly been sizing content so far using the pixel measurement
          (px).
        </li>
        <li>
          Using absolute values can often end with content overflowing from
          their boxes.
        </li>
        <li>
          We can instead use relative values to set the size of an element. The
          element will then be sized to a percentage of its parent element.
        </li>
        <li>
          When no percentage is set, a block element will take up 100% of
          available width. So a percentage value may make it more responsive to
          different screens.
        </li>
      </ul>

      <h2>Styling Images</h2>

      <dl>
        <dt>object-fit: contain;</dt>
        <dd>
          <ul>
            <li>shrinks to fit box on longest side</li>
            <li>maintains aspect ratio</li>
            <li>results in 'letterboxing'</li>
          </ul>
        </dd>

        <dt>object-fit: cover;</dt>
        <dd>
          <ul>
            <li>crops to fit box on shortest side</li>
            <li>maintains aspect ratio</li>
            <li>does not contain whole image</li>
          </ul>
        </dd>

        <dt>object-fit: fill;</dt>
        <dd>
          <ul>
            <li>resizes to fit box on both sides</li>
            <li>does not maintain aspect ratio</li>
          </ul>
        </dd>
      </dl>

      <ul>
        <li>
          Whilst CSS can't affect the internal layout of an image or video, we
          can adjust how they are laid out on the page.
        </li>
        <li>
          If we try to place an image inside a CSS box that isn't the same size
          as the image:
          <ul>
            <li>The image will not stretch to fit a larger box</li>
            <li>The image will overflow out of a smaller box.</li>
          </ul>
        </li>
        <li>
          We can use the <code>object-fit</code> property to ensure our image
          completely covers our box.
        </li>
      </ul>

      <h2>At-rules: Importing Fonts</h2>

      <pre><code class="language-css">@font-face {
  font-family: "MyHelvetica";
  src: local("Helvetica Neue Bold"),
       local("HelveticaNeue-Bold"),
       url("MgOpenModernaBold.ttf");
  font-weight: bold;
}
</code></pre>

      <ul>
        <li>
          At-rules in CSS are specific instructions we can give on how we want
          CSS to behave. We declare an at-rule by using @.
        </li>
        <li>
          The rule then lasts until the next ; on its hierarchy level, or the
          next CSS block - whichever comes first.
        </li>
        <li>
          We can use the <code>@font-face</code> rule to import custom fonts for
          our text: either from our own locally-installed fonts, or from
          external sources.
        </li>
        <li>
          Adding both a local and url source allows for a backup option should
          the user not have that font installed!
        </li>
      </ul>

      <h2>At-rules: Cascade Layers</h2>

      <pre data-line="5"><code class="language-css">/* Layer order */
@layer reset, base, layout

/* Layer styles */
@layer base {
    body {
      display: inline-block;
      font: bold 12px/20px Montserrat blue;
    }
    a {
      color: rebeccapurple;
    }
}

@layer layout {
  #site-header .container {
    display: flex;
    align-items: center;
    justify-content: space-between;
  }
}

/* Styles with no layer take priority */
a {
  color: cornflowerblue;
}
</code></pre>

      <ul>
        <li>
          Another great use of at-rules is for the creation of Cascade Layers.
        </li>
        <li>
          We talked a little bit before about CSS layers in relation to the
          cascade - they allow us to create added layers of specificity into our
          stylesheet.
        </li>
        <li>
          There's a few ways to go about adding layers - our example is the
          <code>@layer</code> block at-rule, which creates a block for that
          layer which you can add styles into.
        </li>
        <li>
          The order of layer creation is important, as it affects the level of
          hierarchy amongst layers. Your reference guide should be able to
          explain more about this.
        </li>
      </ul>
    </main>

    <footer class="margin-start-m padding-m text-center">
      <p>Norwich University of the Arts - Introduction to Web Development</p>
    </footer>
  </body>
</html>
